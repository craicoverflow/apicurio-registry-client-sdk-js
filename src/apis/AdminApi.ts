/* tslint:disable */
/* eslint-disable */
/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.2.0.Final
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    LogConfiguration,
    LogConfigurationFromJSON,
    LogConfigurationToJSON,
    NamedLogConfiguration,
    NamedLogConfigurationFromJSON,
    NamedLogConfigurationToJSON,
    RoleMapping,
    RoleMappingFromJSON,
    RoleMappingToJSON,
    Rule,
    RuleFromJSON,
    RuleToJSON,
    RuleType,
    RuleTypeFromJSON,
    RuleTypeToJSON,
    UpdateRole,
    UpdateRoleFromJSON,
    UpdateRoleToJSON,
} from '../models';

export interface CreateGlobalRuleRequest {
    rule: Rule;
}

export interface CreateRoleMappingRequest {
    roleMapping: RoleMapping;
}

export interface DeleteGlobalRuleRequest {
    rule: RuleType;
}

export interface DeleteRoleMappingRequest {
    principalId: string;
}

export interface GetGlobalRuleConfigRequest {
    rule: RuleType;
}

export interface GetLogConfigurationRequest {
    logger: string;
}

export interface GetRoleMappingRequest {
    principalId: string;
}

export interface ImportDataRequest {
    body: Blob;
}

export interface RemoveLogConfigurationRequest {
    logger: string;
}

export interface SetLogConfigurationRequest {
    logger: string;
    logConfiguration: LogConfiguration;
}

export interface UpdateGlobalRuleConfigRequest {
    rule: RuleType;
    rule2: Rule;
}

export interface UpdateRoleMappingRequest {
    principalId: string;
    updateRole: UpdateRole;
}

/**
 * 
 */
export class AdminApi extends runtime.BaseAPI {

    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * Create global rule
     */
    async createGlobalRuleRaw(requestParameters: CreateGlobalRuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.rule === null || requestParameters.rule === undefined) {
            throw new runtime.RequiredError('rule','Required parameter requestParameters.rule was null or undefined when calling createGlobalRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RuleToJSON(requestParameters.rule),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * Create global rule
     */
    async createGlobalRule(requestParameters: CreateGlobalRuleRequest, initOverrides?: RequestInit): Promise<void> {
        await this.createGlobalRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
     * Create a new role mapping
     */
    async createRoleMappingRaw(requestParameters: CreateRoleMappingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.roleMapping === null || requestParameters.roleMapping === undefined) {
            throw new runtime.RequiredError('roleMapping','Required parameter requestParameters.roleMapping was null or undefined when calling createRoleMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/roleMappings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RoleMappingToJSON(requestParameters.roleMapping),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
     * Create a new role mapping
     */
    async createRoleMapping(requestParameters: CreateRoleMappingRequest, initOverrides?: RequestInit): Promise<void> {
        await this.createRoleMappingRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * Delete all global rules
     */
    async deleteAllGlobalRulesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/rules`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * Delete all global rules
     */
    async deleteAllGlobalRules(initOverrides?: RequestInit): Promise<void> {
        await this.deleteAllGlobalRulesRaw(initOverrides);
    }

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * Delete global rule
     */
    async deleteGlobalRuleRaw(requestParameters: DeleteGlobalRuleRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.rule === null || requestParameters.rule === undefined) {
            throw new runtime.RequiredError('rule','Required parameter requestParameters.rule was null or undefined when calling deleteGlobalRule.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/rules/{rule}`.replace(`{${"rule"}}`, encodeURIComponent(String(requestParameters.rule))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * Delete global rule
     */
    async deleteGlobalRule(requestParameters: DeleteGlobalRuleRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteGlobalRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Delete a role mapping
     */
    async deleteRoleMappingRaw(requestParameters: DeleteRoleMappingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling deleteRoleMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/roleMappings/{principalId}`.replace(`{${"principalId"}}`, encodeURIComponent(String(requestParameters.principalId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Delete a role mapping
     */
    async deleteRoleMapping(requestParameters: DeleteRoleMappingRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteRoleMappingRaw(requestParameters, initOverrides);
    }

    /**
     * Exports registry data as a ZIP archive.
     * Export registry data
     */
    async exportDataRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Blob>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Exports registry data as a ZIP archive.
     * Export registry data
     */
    async exportData(initOverrides?: RequestInit): Promise<Blob> {
        const response = await this.exportDataRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get global rule configuration
     */
    async getGlobalRuleConfigRaw(requestParameters: GetGlobalRuleConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Rule>> {
        if (requestParameters.rule === null || requestParameters.rule === undefined) {
            throw new runtime.RequiredError('rule','Required parameter requestParameters.rule was null or undefined when calling getGlobalRuleConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/rules/{rule}`.replace(`{${"rule"}}`, encodeURIComponent(String(requestParameters.rule))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleFromJSON(jsonValue));
    }

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get global rule configuration
     */
    async getGlobalRuleConfig(requestParameters: GetGlobalRuleConfigRequest, initOverrides?: RequestInit): Promise<Rule> {
        const response = await this.getGlobalRuleConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
     * Get a single logger configuration
     */
    async getLogConfigurationRaw(requestParameters: GetLogConfigurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NamedLogConfiguration>> {
        if (requestParameters.logger === null || requestParameters.logger === undefined) {
            throw new runtime.RequiredError('logger','Required parameter requestParameters.logger was null or undefined when calling getLogConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/loggers/{logger}`.replace(`{${"logger"}}`, encodeURIComponent(String(requestParameters.logger))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedLogConfigurationFromJSON(jsonValue));
    }

    /**
     * Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
     * Get a single logger configuration
     */
    async getLogConfiguration(requestParameters: GetLogConfigurationRequest, initOverrides?: RequestInit): Promise<NamedLogConfiguration> {
        const response = await this.getLogConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Return a single role mapping
     */
    async getRoleMappingRaw(requestParameters: GetRoleMappingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<RoleMapping>> {
        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling getRoleMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/roleMappings/{principalId}`.replace(`{${"principalId"}}`, encodeURIComponent(String(requestParameters.principalId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RoleMappingFromJSON(jsonValue));
    }

    /**
     * Gets the details of a single role mapping (by principalId).  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Return a single role mapping
     */
    async getRoleMapping(requestParameters: GetRoleMappingRequest, initOverrides?: RequestInit): Promise<RoleMapping> {
        const response = await this.getRoleMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Imports registry data that was previously exported using the `/admin/export` operation.
     * Import registry data
     */
    async importDataRaw(requestParameters: ImportDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling importData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/zip';

        const response = await this.request({
            path: `/admin/import`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Imports registry data that was previously exported using the `/admin/export` operation.
     * Import registry data
     */
    async importData(requestParameters: ImportDataRequest, initOverrides?: RequestInit): Promise<void> {
        await this.importDataRaw(requestParameters, initOverrides);
    }

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * List global rules
     */
    async listGlobalRulesRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<RuleType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RuleTypeFromJSON));
    }

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * List global rules
     */
    async listGlobalRules(initOverrides?: RequestInit): Promise<Array<RuleType>> {
        const response = await this.listGlobalRulesRaw(initOverrides);
        return await response.value();
    }

    /**
     * List all of the configured logging levels.  These override the default logging configuration.
     * List logging configurations
     */
    async listLogConfigurationsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<NamedLogConfiguration>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/loggers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NamedLogConfigurationFromJSON));
    }

    /**
     * List all of the configured logging levels.  These override the default logging configuration.
     * List logging configurations
     */
    async listLogConfigurations(initOverrides?: RequestInit): Promise<Array<NamedLogConfiguration>> {
        const response = await this.listLogConfigurationsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * List all role mappings
     */
    async listRoleMappingsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Array<RoleMapping>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/roleMappings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RoleMappingFromJSON));
    }

    /**
     * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * List all role mappings
     */
    async listRoleMappings(initOverrides?: RequestInit): Promise<Array<RoleMapping>> {
        const response = await this.listRoleMappingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Removes the configured logger configuration (if any) for the given logger.
     * Removes logger configuration
     */
    async removeLogConfigurationRaw(requestParameters: RemoveLogConfigurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NamedLogConfiguration>> {
        if (requestParameters.logger === null || requestParameters.logger === undefined) {
            throw new runtime.RequiredError('logger','Required parameter requestParameters.logger was null or undefined when calling removeLogConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/loggers/{logger}`.replace(`{${"logger"}}`, encodeURIComponent(String(requestParameters.logger))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedLogConfigurationFromJSON(jsonValue));
    }

    /**
     * Removes the configured logger configuration (if any) for the given logger.
     * Removes logger configuration
     */
    async removeLogConfiguration(requestParameters: RemoveLogConfigurationRequest, initOverrides?: RequestInit): Promise<NamedLogConfiguration> {
        const response = await this.removeLogConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Configures the logger referenced by the provided logger name with the given configuration.
     * Set a logger\'s configuration
     */
    async setLogConfigurationRaw(requestParameters: SetLogConfigurationRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<NamedLogConfiguration>> {
        if (requestParameters.logger === null || requestParameters.logger === undefined) {
            throw new runtime.RequiredError('logger','Required parameter requestParameters.logger was null or undefined when calling setLogConfiguration.');
        }

        if (requestParameters.logConfiguration === null || requestParameters.logConfiguration === undefined) {
            throw new runtime.RequiredError('logConfiguration','Required parameter requestParameters.logConfiguration was null or undefined when calling setLogConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/loggers/{logger}`.replace(`{${"logger"}}`, encodeURIComponent(String(requestParameters.logger))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: LogConfigurationToJSON(requestParameters.logConfiguration),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NamedLogConfigurationFromJSON(jsonValue));
    }

    /**
     * Configures the logger referenced by the provided logger name with the given configuration.
     * Set a logger\'s configuration
     */
    async setLogConfiguration(requestParameters: SetLogConfigurationRequest, initOverrides?: RequestInit): Promise<NamedLogConfiguration> {
        const response = await this.setLogConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update global rule configuration
     */
    async updateGlobalRuleConfigRaw(requestParameters: UpdateGlobalRuleConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Rule>> {
        if (requestParameters.rule === null || requestParameters.rule === undefined) {
            throw new runtime.RequiredError('rule','Required parameter requestParameters.rule was null or undefined when calling updateGlobalRuleConfig.');
        }

        if (requestParameters.rule2 === null || requestParameters.rule2 === undefined) {
            throw new runtime.RequiredError('rule2','Required parameter requestParameters.rule2 was null or undefined when calling updateGlobalRuleConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/rules/{rule}`.replace(`{${"rule"}}`, encodeURIComponent(String(requestParameters.rule))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RuleToJSON(requestParameters.rule2),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleFromJSON(jsonValue));
    }

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update global rule configuration
     */
    async updateGlobalRuleConfig(requestParameters: UpdateGlobalRuleConfigRequest, initOverrides?: RequestInit): Promise<Rule> {
        const response = await this.updateGlobalRuleConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update a role mapping
     */
    async updateRoleMappingRaw(requestParameters: UpdateRoleMappingRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.principalId === null || requestParameters.principalId === undefined) {
            throw new runtime.RequiredError('principalId','Required parameter requestParameters.principalId was null or undefined when calling updateRoleMapping.');
        }

        if (requestParameters.updateRole === null || requestParameters.updateRole === undefined) {
            throw new runtime.RequiredError('updateRole','Required parameter requestParameters.updateRole was null or undefined when calling updateRoleMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/roleMappings/{principalId}`.replace(`{${"principalId"}}`, encodeURIComponent(String(requestParameters.principalId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRoleToJSON(requestParameters.updateRole),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update a role mapping
     */
    async updateRoleMapping(requestParameters: UpdateRoleMappingRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateRoleMappingRaw(requestParameters, initOverrides);
    }

}
