/* tslint:disable */
/* eslint-disable */
/**
 * Apicurio Registry API [v2]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 2.2.0.Final
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ArtifactMetaData,
    ArtifactMetaDataFromJSON,
    ArtifactMetaDataToJSON,
    EditableMetaData,
    EditableMetaDataFromJSON,
    EditableMetaDataToJSON,
    VersionMetaData,
    VersionMetaDataFromJSON,
    VersionMetaDataToJSON,
} from '../models';

export interface DeleteArtifactVersionMetaDataRequest {
    groupId: string;
    artifactId: string;
    version: string;
}

export interface GetArtifactMetaDataRequest {
    groupId: string;
    artifactId: string;
}

export interface GetArtifactVersionMetaDataRequest {
    groupId: string;
    artifactId: string;
    version: string;
}

export interface GetArtifactVersionMetaDataByContentRequest {
    groupId: string;
    artifactId: string;
    body: Blob;
    canonical?: boolean;
}

export interface UpdateArtifactMetaDataRequest {
    groupId: string;
    artifactId: string;
    editableMetaData: EditableMetaData;
}

export interface UpdateArtifactVersionMetaDataRequest {
    groupId: string;
    artifactId: string;
    version: string;
    editableMetaData: EditableMetaData;
}

/**
 * 
 */
export class MetadataApi extends runtime.BaseAPI {

    /**
     * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Delete artifact version metadata
     */
    async deleteArtifactVersionMetaDataRaw(requestParameters: DeleteArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling deleteArtifactVersionMetaData.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling deleteArtifactVersionMetaData.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling deleteArtifactVersionMetaData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the user-editable metadata properties of the artifact version.  Any properties that are not user-editable are preserved.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Delete artifact version metadata
     */
    async deleteArtifactVersionMetaData(requestParameters: DeleteArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<void> {
        await this.deleteArtifactVersionMetaDataRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * Get artifact metadata
     */
    async getArtifactMetaDataRaw(requestParameters: GetArtifactMetaDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ArtifactMetaData>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getArtifactMetaData.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling getArtifactMetaData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtifactMetaDataFromJSON(jsonValue));
    }

    /**
     * Gets the metadata for an artifact in the registry.  The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * Get artifact metadata
     */
    async getArtifactMetaData(requestParameters: GetArtifactMetaDataRequest, initOverrides?: RequestInit): Promise<ArtifactMetaData> {
        const response = await this.getArtifactMetaDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get artifact version metadata
     */
    async getArtifactVersionMetaDataRaw(requestParameters: GetArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<VersionMetaData>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getArtifactVersionMetaData.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling getArtifactVersionMetaData.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling getArtifactVersionMetaData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionMetaDataFromJSON(jsonValue));
    }

    /**
     * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get artifact version metadata
     */
    async getArtifactVersionMetaData(requestParameters: GetArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<VersionMetaData> {
        const response = await this.getArtifactVersionMetaDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get artifact version metadata by content
     */
    async getArtifactVersionMetaDataByContentRaw(requestParameters: GetArtifactVersionMetaDataByContentRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<VersionMetaData>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling getArtifactVersionMetaDataByContent.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling getArtifactVersionMetaDataByContent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling getArtifactVersionMetaDataByContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.canonical !== undefined) {
            queryParameters['canonical'] = requestParameters.canonical;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VersionMetaDataFromJSON(jsonValue));
    }

    /**
     * Gets the metadata for an artifact that matches the raw content.  Searches the registry for a version of the given artifact matching the content provided in the body of the POST.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * No artifact with the `artifactId` exists (HTTP error `404`) * No artifact version matching the provided content exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Get artifact version metadata by content
     */
    async getArtifactVersionMetaDataByContent(requestParameters: GetArtifactVersionMetaDataByContentRequest, initOverrides?: RequestInit): Promise<VersionMetaData> {
        const response = await this.getArtifactVersionMetaDataByContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * Update artifact metadata
     */
    async updateArtifactMetaDataRaw(requestParameters: UpdateArtifactMetaDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling updateArtifactMetaData.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling updateArtifactMetaData.');
        }

        if (requestParameters.editableMetaData === null || requestParameters.editableMetaData === undefined) {
            throw new runtime.RequiredError('editableMetaData','Required parameter requestParameters.editableMetaData was null or undefined when calling updateArtifactMetaData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditableMetaDataToJSON(requestParameters.editableMetaData),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  For example, `createdOn` and `createdBy` are both read-only properties.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * Update artifact metadata
     */
    async updateArtifactMetaData(requestParameters: UpdateArtifactMetaDataRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateArtifactMetaDataRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update artifact version metadata
     */
    async updateArtifactVersionMetaDataRaw(requestParameters: UpdateArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
            throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling updateArtifactVersionMetaData.');
        }

        if (requestParameters.artifactId === null || requestParameters.artifactId === undefined) {
            throw new runtime.RequiredError('artifactId','Required parameter requestParameters.artifactId was null or undefined when calling updateArtifactVersionMetaData.');
        }

        if (requestParameters.version === null || requestParameters.version === undefined) {
            throw new runtime.RequiredError('version','Required parameter requestParameters.version was null or undefined when calling updateArtifactVersionMetaData.');
        }

        if (requestParameters.editableMetaData === null || requestParameters.editableMetaData === undefined) {
            throw new runtime.RequiredError('editableMetaData','Required parameter requestParameters.editableMetaData was null or undefined when calling updateArtifactVersionMetaData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta`.replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters.groupId))).replace(`{${"artifactId"}}`, encodeURIComponent(String(requestParameters.artifactId))).replace(`{${"version"}}`, encodeURIComponent(String(requestParameters.version))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditableMetaDataToJSON(requestParameters.editableMetaData),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * Update artifact version metadata
     */
    async updateArtifactVersionMetaData(requestParameters: UpdateArtifactVersionMetaDataRequest, initOverrides?: RequestInit): Promise<void> {
        await this.updateArtifactVersionMetaDataRaw(requestParameters, initOverrides);
    }

}
